/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 houdiniSpherePoints3.gltf --transform
*/

import React, { useMemo, useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { Group, Mesh, Points, Vector3 } from 'three'
import DnaPoints from './DnaPoints';
import { useFrame } from '@react-three/fiber';

type VectorArray = [x: number, y:number, z:number];

type DnaSphereProps = {
  opacity?: number;
  speed?: number;
  animateIn?: number;
  animateDna?: number;
  position: VectorArray;
};

const lerp = (a: number, b:number, t: number) => {
  return a + (b - a) * t;
}

const DnaSphere = ({ opacity = 1.0, speed = 0.5, animateIn = 0, animateDna = 0, position, ...props }: DnaSphereProps)  => {
  const groupRef = useRef<Group>(null);
  const { nodes } = useGLTF('/HoudiniSphereWithPoints-transformed.glb') as unknown as { nodes: { SphereMesh: Mesh, DnaStrands: Points, SpherePoints: Points }}
  const rotation = useMemo(() => (
    new Vector3(Math.random() * speed, Math.random() * speed, Math.random() * speed)
  ), []);
  const pos: VectorArray = useMemo(() => [position[0], lerp(3 * Math.abs(position[2]), position[1], animateIn), position[2]], [animateIn]);

  useFrame((state) => {
    if(!groupRef.current) return;
    const t = state.clock.getElapsedTime();
    groupRef.current.rotation.x = rotation.x * t;
    groupRef.current.rotation.y = rotation.y * t;
    groupRef.current.rotation.z = rotation.z * t;
  }) 

  return (
    
    <group ref={groupRef} position={pos} {...props} dispose={null}>
      <mesh
        geometry={nodes.SphereMesh.geometry}
        material={nodes.SphereMesh.material}
        castShadow
        receiveShadow
        scale={animateIn}
      >
        <meshStandardMaterial transparent opacity={opacity} color={[0.045,0.045, 0.05]} metalness={0.0} roughness={1.0}/>
      </mesh>
      <DnaPoints animateDna={animateDna} opacity={opacity} />
    </group>

  )
}

export default DnaSphere;

useGLTF.preload('/HoudiniSphereWithPoints-transformed.glb')